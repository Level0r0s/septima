import com.septima.entities.SqlEntities
import com.septima.generator.EntitiesRows
import com.septima.generator.Models
import com.zaxxer.hikari.HikariConfig
import com.zaxxer.hikari.HikariDataSource

import javax.naming.Context
import javax.naming.InitialContext
import javax.naming.NamingException
import javax.naming.spi.InitialContextFactory
import java.util.concurrent.ConcurrentHashMap

class GenerateEntities extends DefaultTask {

    def SqlEntities sqlEntities

    EntitiesRows generator

    @InputDirectory
    def File sqlEntitiesDir

    @OutputDirectory
    def File generatedSourcesDir

    @TaskAction
    void generate(IncrementalTaskInputs inputs) {
        if (sqlEntities == null)
            throw new GradleException("'sqlEntities' property is required for" +
                    " the task")
        if (generator == null)
            generator = EntitiesRows.fromResources(sqlEntities, generatedSourcesDir.toPath())

        if (!inputs.incremental) {
            project.delete generatedSourcesDir.listFiles()
        }

        def transform = { sqlEntity ->
            def generatedClass = generator.toJavaSource(sqlEntity.toPath())
            println "Sql entity definition '${sqlEntity}' transformed to '${generatedClass}'"
        }

        inputs.outOfDate { change ->
            if (change.file.name.endsWith(".sql")) {
                transform change.file
            } else if (change.file.name.endsWith(".sql.json")) {
                Path origin = change.file.toPath().resolveSibling(change.file.name.substring(0, change.file.name.length() - 5))
                if (origin.toFile().exists()) {
                    transform origin.toFile()
                }
            }
        }

        def removeGeneratedClassBySqlFile = { file ->
            def targetFile = generator.considerJavaSource(file.toPath()).toFile()
            if (targetFile.exists()) {
                targetFile.delete()
                println "Removed generated entity class  : ${targetFile}"
            }
        }

        inputs.removed { change ->
            if (change.file.name.endsWith(".sql")) {
                removeGeneratedClassBySqlFile(change.file)
            } else if (change.file.name.endsWith(".sql.json")) {
                File origin = change.file.toPath().resolveSibling(change.file.name.substring(0, change.file.name.length() - 5)).toFile()
                if (origin.exists()) {
                    removeGeneratedClassBySqlFile(origin)
                }
            }
        }
    }
}

class GenerateModels extends DefaultTask {

    Models generator

    def SqlEntities sqlEntities

    @InputDirectory
    def File modelsDir

    @OutputDirectory
    def File generatedSourcesDir

    @TaskAction
    void generate(IncrementalTaskInputs inputs) {
        if (sqlEntities == null)
            throw new GradleException("Property 'sqlEntities' is required for" +
                    " the task")
        if (generator == null)
            generator = Models.fromResources(sqlEntities, modelsDir.toPath(), generatedSourcesDir.toPath())

        if (!inputs.incremental) {
            project.delete generatedSourcesDir.listFiles()
        }

        inputs.outOfDate { change ->
            if (change.file.name.endsWith(".model.json")) {
                def generatedClass = generator.toJavaSource(change.file.toPath())
                println "Model definition '${change.file}' transformed to '${generatedClass}'"
            }
        }

        inputs.removed { change ->
            if (change.file.name.endsWith(".model.json")) {
                def targetFile = generator.considerJavaSource(change.file.toPath()).toFile()
                if (targetFile.exists()) {
                    targetFile.delete()
                    println "Removed generated model class  : ${targetFile}"
                }
            }
        }
    }
}

class Jndi implements InitialContextFactory {

    private static final Map<String, Object> binds = new ConcurrentHashMap<>()

    private class InitialMemoryContext extends InitialContext {

        InitialMemoryContext(Hashtable<?, ?> env) throws NamingException {
        }

        @Override
        protected void init(Hashtable<?, ?> environment) throws NamingException {
            // no op here to avoid recursion with InitialContext
        }

        Object lookup(String name) throws NamingException {
            if (!binds.containsKey(name)) {
                throw new NamingException(name + " is not bound")
            }
            return binds.get(name)
        }

        void bind(String name, Object obj) throws NamingException {
            binds.put(name, obj);
        }

        void unbind(String name) throws NamingException {
            binds.remove(name)
        }

    }

    @Override
    Context getInitialContext(Hashtable<?, ?> environment) throws NamingException {
        return new InitialMemoryContext(environment);
    }
}

System.setProperty(Context.INITIAL_CONTEXT_FACTORY, Jndi.class.getName())

buildscript {
    repositories {
        jcenter()
        mavenLocal()
    }
    dependencies {
        classpath 'com.h2database:h2:1.4.193',
                'com.septimajs:septima-js-model:0.0.1',
                'com.septimajs:septima-js-generator:0.0.1',
                'com.zaxxer:HikariCP:2.7.6'
    }
}

apply plugin: 'war'
apply plugin: 'war'

sourceSets {
    main {
        java {
            srcDirs = ['src/server/main/java', "${buildDir}/generated-src/entities", "${buildDir}/generated-src/models"]
        }
        resources {
            srcDirs = ['src/server/main/resources']
        }
    }
    test {
        java {
            srcDirs = ['src/server/test/java']
        }
        resources {
            srcDirs = ['src/server/test/resources']
        }
    }
}

configurations {
    compile.transitive = false
    tomcat
    containerLibs
    h2
}

def tomcatVersion = '8.5.8'

dependencies {
    compileOnly 'javax.servlet:javax.servlet-api:3.1.0',
            'javax.websocket:javax.websocket-api:1.1',
            'javax.mail:mail:1.4.7'
    compile project(':septima-js-model'),
            project(':septima-js-data'),
            project(':septima-js-application'),
            'com.fasterxml.jackson.core:jackson-core:2.9.2',
            'com.fasterxml.jackson.core:jackson-databind:2.9.2'
    tomcat "org.apache.tomcat:tomcat-catalina:$tomcatVersion",
            "org.apache.tomcat:tomcat-jasper:$tomcatVersion",
            "org.apache.tomcat:tomcat-dbcp:$tomcatVersion",
            "org.apache.tomcat:tomcat-websocket:$tomcatVersion",
            "org.apache.tomcat:tomcat-jaspic-api:$tomcatVersion"
    containerLibs 'com.h2database:h2:1.4.193'
    // , ... another jdbc driver for another database
    h2 'com.h2database:h2:1.4.193'
}

def tomcatDir = "${buildDir}/tomcat"
def tomcatBinDir = "${tomcatDir}/bin"
def sharedLibDir = "${tomcatDir}/lib"
def h2Dir = "${System.getProperty('user.home')}/.septima/h2"

task buildTomcatBin(type: Copy) {
    configurations.tomcat.each {
        from file(it)
    }
    into tomcatBinDir
}

task buildSharedLibs(type: Copy) {
    configurations.containerLibs.each {
        from file(it)
    }
    into sharedLibDir
}

task buildTomcat() {
}

buildTomcat.dependsOn buildTomcatBin,
        buildSharedLibs

task cleanTomcat(type: Delete) {
    delete tomcatDir
}

clean.dependsOn cleanTomcat

def asProps = { fileName ->
    def loaded = new Properties()
    def inputFile = file(fileName)
    if (inputFile.exists()) {
        inputFile.withInputStream {
            loaded.load(it)
        }
    }
    return loaded
}

def check = { map, prop, value ->
    if (!map.containsKey(prop)) {
        map[prop] = value
    }
}

def props = asProps('project.properties')
check props, 'application.context', 'change-me-context'

def privateProps = asProps('private.properties')
check privateProps, 'tomcat.http.port', 8085
check privateProps, 'tomcat.log.level', 'INFO'
check privateProps, 'tomcat.debug.port', 5007
check privateProps, 'application.security', false

def dataSources = [] as Set
props.each {
    def matcher = (it.key =~ "data-source\\.([a-zA-Z_/\\-]+)\\..*")
    if (matcher.matches()) {
        def dsName = matcher.group(1)
        def dbUrl = props["data-source.${dsName}.dburl"]
        if (!dbUrl)
            throw new GradleException("'data-source.${dsName}.dburl' project property not found or is not defined")
        def jdbcDriverClass = props["data-source.${dsName}.jdbcDriverClass"]
        if (!jdbcDriverClass)
            throw new GradleException("'data-source.${dsName}.jdbcDriverClass' project property not found or is not defined")
        def dbUser = props["data-source.${dsName}.dbuser"]
        if (!dbUser)
            throw new GradleException("'data-source.${dsName}.dbuser' project property not found or is not defined")
        def dbPassword = props["data-source.${dsName}.dbpassword"]
        def dbSchema = props["data-source.${dsName}.dbschema"]
        def maxConnections = props["data-source.${dsName}.max.connections"]
        def maxStatements = props["data-source.${dsName}.max.statements"]
        dataSources << [
                name          : dsName,
                url           : dbUrl,
                driverClass   : jdbcDriverClass,
                user          : dbUser,
                password      : dbPassword,
                schema        : dbSchema,
                maxConnections: maxConnections,
                maxStatements : maxStatements
        ]
    }
}

task warExplode(type: Copy) {
    with war
    into "$tomcatDir/web-apps/${props['application.context']}"
}

def webAppUrl = privateProps['browser.url'] ? privateProps['browser.url'] : "http://localhost:${privateProps['tomcat.http.port']}/${props['application.context']}"

task configureTomcat(type: Copy) {
    def confSourceDir = 'src/server/tomcat'
    def confDestDir = "${tomcatDir}/conf"
    outputs.upToDateWhen { false }
    from confSourceDir
    into confDestDir
    include 'default-web.xml'
    rename 'default-web.xml', 'web.xml'
    doLast {
        def conf = file("${confSourceDir}/server.xml").withInputStream {
            return new XmlParser().parse(it)
        }
        def connectors = conf.Service.Connector
        if (connectors.isEmpty())
            throw new GradleException("'Connector' tag not found in server.xml or it is not on path: 'Server/Service/Connector'")
        def connectorNode = connectors[0]
        connectorNode.attributes()['port'] = privateProps['tomcat.http.port']

        def contexts = conf.Service.Engine.Host.Context
        if (contexts.isEmpty())
            throw new GradleException("'Context' tag not found in server.xml or it is not on path: 'Server/Service/Engine/Host/Context'")
        def contextNode = contexts[0]
        contextNode.attributes()['path'] = "/${props['application.context']}"
        contextNode.attributes()['docBase'] = "${tomcatDir}/web-apps/${props['application.context']}"
        def generalDsName = props['application.data-source']
        def enableSecurityRealm = privateProps['application.security'] == 'true'
        def realmAdded = false
        dataSources.each {
            def ds = it

            if (enableSecurityRealm && generalDsName && generalDsName == ds.name) {
                def realmNode = contextNode.appendNode(new groovy.xml.QName("Realm"), [
                        'className'      : "org.apache.catalina.realm.DataSourceRealm",
                        'dataSourceName' : ds.name,
                        'localDataSource': "true",
                        'roleNameCol'    : "GROUP_NAME",
                        'userCredCol'    : "USR_PASSWD",
                        'userNameCol'    : "USR_NAME",
                        'userRoleTable'  : "APP_USERS_GROUPS",
                        'userTable'      : "APP_USERS"
                ])
                realmNode.appendNode(new groovy.xml.QName("CredentialHandler"), [
                        className: "org.apache.catalina.realm.MessageDigestCredentialHandler",
                        algorithm: "md5"
                ])
                realmAdded = true
            }
            def dsAttributes = [
                    name           : ds.name,
                    url            : ds.url,
                    username       : ds.user,
                    driverClassName: ds.driverClass,
                    type           : 'javax.sql.DataSource'
            ]
            if (ds.password != null)
                dsAttributes.password = ds.password

//            if(ds.schema != null)
//                dsAttributes.schema = ds.schema
//            if(ds.maxConnections != null)
//                dsAttributes.maxActive = ds.maxConnections
//            if(ds.maxStatements != null)
//                dsAttributes.maxStatements = ds.maxStatements

            contextNode.appendNode(new groovy.xml.QName('Resource'), dsAttributes)
        }
        if (enableSecurityRealm && !realmAdded) {
            throw new GradleException("Security realm can not be added because application data source is not found.")
        }
        file("${confDestDir}/server.xml").withOutputStream {
            groovy.xml.XmlUtil.serialize(conf, it)
        }
        def loggingProps = asProps("${confSourceDir}/logging.properties")
        loggingProps['org.apache.juli.FileHandler.level'] = privateProps['tomcat.log.level']
        loggingProps['java.util.logging.ConsoleHandler.level'] = privateProps['tomcat.log.level']
        file("${confDestDir}/logging.properties").withOutputStream {
            loggingProps.store(it, 'Tomcat logging configuration. Septima profile.')
        }
    }
}

task tomcatCommand(type: JavaExec) {
    workingDir tomcatDir
    classpath fileTree(tomcatBinDir)
    main 'org.apache.catalina.startup.Bootstrap'
    jvmArgs '-Xdebug',
            "-Xrunjdwp:server=y,transport=dt_socket,address=${privateProps['tomcat.debug.port']},suspend=n",
            "-Djava.util.logging.config.file=${file(tomcatDir)}/conf/logging.properties"
}

def launchTomcat = {
    def instance = new ProcessBuilder(tomcatCommand.commandLine)
            .directory(file(tomcatCommand.workingDir))
            .redirectErrorStream(true).start()
    def stdOut = new InputStreamReader(instance.getInputStream())
    try {
        def tomcatNextLine = stdOut.readLine()
        while (!tomcatNextLine.contains('Server startup in')) {
            if (!tomcatNextLine.isEmpty())
                println(tomcatNextLine)
            tomcatNextLine = stdOut.readLine()
        }
        if (!tomcatNextLine.isEmpty())
            println(tomcatNextLine)
        println()
        println 'Tomcat started.'
        println "Further logs you can find at: ${tomcatDir}/logs"
    } finally {
        stdOut.close()
    }
    return instance
}

def shutdownTomcat = { instance ->
    instance.destroy()
    instance.waitFor()
    println()
    println 'Tomcat shutted down'
}

task buildH2(type: Copy) {
    configurations.h2.each {
        from file(it)
    }
    into h2Dir
}

task h2Command(type: JavaExec) {
    classpath fileTree(h2Dir)
    main 'org.h2.tools.Server'
    args '-tcp'
}

def launchH2 = {
    def h2Server = new ProcessBuilder(h2Command.commandLine)
            .redirectErrorStream(true)
            .start()
    def h2StdOut = new InputStreamReader(h2Server.getInputStream())
    try {
        def h2NextLine = h2StdOut.readLine()
        while (!h2NextLine.contains('TCP server running at')) {
            if (!h2NextLine.isEmpty())
                println(h2NextLine)
            h2NextLine = h2StdOut.readLine()
        }
        if (!h2NextLine.isEmpty())
            println(h2NextLine)
        println("H2 server started")
        println()
    } finally {
        h2StdOut.close()
    }
    return h2Server
}

task fillH2(type: Copy) {
    from "${projectDir}"
    include 'base.sql'
    into "$buildDir/tmp/database/"
    rename 'base.sql', 'base.sql.applied'

    doFirst {
        def runScript = {
            org.h2.tools.RunScript.main(
                    '-url', props["data-source.${props['application.data-source']}.dburl"],
                    '-user', props["data-source.${props['application.data-source']}.dbuser"],
                    '-password', props["data-source.${props['application.data-source']}.dbpassword"],
                    '-script', 'base.sql'
            )
            println 'Application database filled'
        }
        try {
            runScript()
        } catch (org.h2.jdbc.JdbcSQLException ex) {
            if (ex.cause instanceof java.net.ConnectException) {
                println 'H2 is not running. Trying to start it ...'
                launchH2()
                runScript()
            } else {
                throw ex
            }
        }
    }
    doLast {
        delete generateEntities.outputs
        println 'Generated entities cleared'
    }
}
fillH2.dependsOn buildH2


task run() {
    doFirst {
        def tomcatServer = launchTomcat()
        println "Application is now served at ${webAppUrl}"
        println()
        println 'To terminate press enter ...'
        System.in.read()
        shutdownTomcat tomcatServer
        println()
        println 'See you next time :)'
    }
}
run.dependsOn buildTomcat,
        configureTomcat,
        warExplode,
        fillH2

task bindDataSources() {
    doFirst {
        def naming = new InitialContext()
        dataSources.forEach {
            HikariConfig config = new HikariConfig()
            config.jdbcUrl = it.url
            config.username = it.user
            config.driverClassName = it.driverClass
            if (it.password != null)
                config.password = it.password
            if (it.maxConnections != null)
                config.maximumPoolSize = it.maxConnections
            // ds.maxStatements
            //if (it.schema != null)
            //    config.schema = it.schema
            naming.bind it.name, new HikariDataSource(config)
        }
        println 'data sources bound'
    }
}
bindDataSources.dependsOn fillH2

def sqlEntitiesSource = new SqlEntities(file('src/server/main/resources/entities').toPath(), props['application.data-source'])

task generateEntities(type: GenerateEntities) {
    sqlEntities = sqlEntitiesSource
    sqlEntitiesDir = sqlEntitiesSource.getEntitiesRoot().toFile()
    generatedSourcesDir = file("${buildDir}/generated-src/entities")
    doLast {
        delete generateModels.outputs
        println 'Generated models cleared'
    }
}
generateEntities.dependsOn bindDataSources

task generateModels(type: GenerateModels) {
    sqlEntities = sqlEntitiesSource
    modelsDir = file('src/server/main/models')
    generatedSourcesDir = file("${buildDir}/generated-src/models")
}
generateModels.dependsOn generateEntities

compileJava.dependsOn generateModels